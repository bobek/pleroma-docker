#!/bin/bash

set -e

print_help() {
    echo "
Pleroma Maintenance Script

Usage:
    $0 [action]

Actions:
    build                     Rebuild the pleroma container

    start / up                Start pleroma and sibling services

    stop / down               Stop pleroma and sibling services

    restart                   Executes #stop and #start respectively.

    status / ps               Show the current container status

    logs                      Show the current container logs

    enter                     Enter the pleroma container for debugging/maintenance

    mix [task] [args...]      Run a mix task without entering the container

    dump                      Dump the generated docker-compose.yml to stdout

Environment:
    DEBUG can be used to modify the loglevel.
        DEBUG=1 prints all commands before they are executed.
        DEBUG=2 prints all bash statements before they are executed (a lot).

    SHOPT can be used to modify shell options.
        Pass a list of options to this variable like SHOPT='-x -e'.
        -e is always on unless you set it to +e.

        For setting long options with -o use a colon (:) instead of a space
        to seperate the option from -o. For example: SHOPT='-x -e -o:pipefail'

Contributing:
    You can report bugs or contribute to this project at:
        https://glitch.sh/sn0w/pleroma-docker
"
}

flags=""

render_template() {
    m4 $flags docker-compose.m4 | awk 'NF'
}

docker_compose() {
    docker-compose \
        -f <(render_template) \
        --project-directory . \
        --project-name "${PLEROMA_NAME:-pleroma}" \
        "$@"
}

load_env() {
    if [[ ! -f .env ]]; then
        echo "Please create a .env file first"
        echo "(Copy .env.dist to .env for a template)"
        exit 1
    fi

    while read -r line; do
        if [[ "$line" == \#* ]] || [[ -z "$line" ]]; then
            continue;
        fi

        export "${line?}"
        flags="-D__${line?} $flags"
    done < .env
}

action__build()   { docker_compose build --build-arg __BUST_CACHE="$(date +%s)" server; }
action__debug()   { render_template; }
action__down()    { action__stop; }
action__enter()   { docker_compose exec server ash -c 'cd /pleroma && ash'; }
action__lint()    { render_template | jq; }
action__logs()    { docker_compose logs -f; }
action__mix()     { docker_compose exec server ash -c "cd /pleroma && mix $*"; }
action__ps()      { action__status; }
action__restart() { action__stop; action__start; }
action__start()   { docker_compose up --remove-orphans -d; }
action__status()  { docker_compose ps; }
action__stop()    { docker_compose down; }
action__up()      { action__start; }

action__dump() {
    if command -v jq 2>&1 1>/dev/null; then
        cat <(render_template) | jq
    else
        cat <(render_template)
    fi
}

# Check if there is any command at all
if [[ -z "$1" ]]; then
    print_help
    exit 1
fi

# Check for SHOPTs
if [[ ! -z "$SHOPT" ]]; then
    for opt in $SHOPT; do
        if [[ $opt =~ ":" ]]; then
            set -o ${opt//-o:/}
        else
            set $opt
        fi
    done
fi

# Check for DEBUG
if [[ ! -z "$DEBUG" ]]; then
    if [[ $DEBUG == 1 ]]; then
        export DEBUG_COMMANDS=1
    elif [[ $DEBUG == 2 ]]; then
        set -x
    fi
fi

# Parse .env
load_env

# Guess function name of current command
# and then check for it's existance.
func="action__${1}"

if type -t $func 2>&1 1>/dev/null; then
    shift
    [[ $DEBUG != 1 ]] || set -x
    $func $@
    { [[ $DEBUG != 1 ]] || set +x; } 2>/dev/null
else
    print_help
    exit 1
fi
